#pragma config(Sensor, in1,    ,               sensorPotentiometer)
#pragma config(Sensor, in8,    ChainBarPot,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  goalLift,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  claw,           sensorDigitalOut)
#pragma config(Motor,  port1,           LeftArm,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftBack1,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LeftBack2,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           LeftFront1,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           LeftFront2,    tmotorNone, openLoop)
#pragma config(Motor,  port6,           RightFront1,   tmotorNone, openLoop)
#pragma config(Motor,  port7,           RightFront2,   tmotorNone, openLoop)
#pragma config(Motor,  port8,           RightBack1,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           RightBack2,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port10,          RightArm,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// int statement used for numbers.
int threshold = 15; // setting variable to stop toggle from making noise if not set to zero.
// Bool statement used for true and false.
bool GoalPosition = false; // this variable will decide whether the goal is up or down.
bool ClawPosition = false;
int desiredPotValue = 0; // will be set to whatever position the arm is at the start
int PotFullyForwardValue = 62;
int PotFullyBackwardValue = 4000;
int millisecondsForFullShoulderTravel = 2000;
unsigned long programTimeAtLastJoystickCheck = 0;

void NormalTankDrive(){ // setting the task for normal tank drive, it will be using two toggles

	//Right side drive. Motors will be moving in opposite direction to left side.
	int RightDriveSpeed = 0; // setting start speed to zero.
	if (abs(vexRT[Ch2]) > threshold) { // the toggle is outside of the toggle range
		RightDriveSpeed = vexRT[Ch2] * -1; // the negative means the motor will be moving opposite to left side
	}
	// however far the toggle is pushed, both motors will recieve same data and will therefore move at the same speed
	motor[RightBack1] = RightDriveSpeed;
	motor[RightBack2] = RightDriveSpeed;
	motor[RightFront1] = RightDriveSpeed;
	motor[RightFront2] = RightDriveSpeed;

	//Left side drive. Motors will be moving in opposite direction to right side.
	int LeftDriveSpeed = 0; // setting start speed to zero.
	if (abs(vexRT[Ch3]) > threshold) { // the toggle is outside of the toggle range
		LeftDriveSpeed = vexRT[Ch3]; // no negative sign needed. Data taken from left toggle.
	}
	// however far the toggle is pushed, both motors will recieve same data and will therefore move at the same speed
	motor[LeftBack1] = LeftDriveSpeed;
	motor[LeftBack2] = LeftDriveSpeed;
	motor[LeftFront1] = LeftDriveSpeed;
	motor[LeftFront2] = LeftDriveSpeed;

}

void arcadeDriveFromLeftJoystick() { // this will be used to precisely pick up the cones.

int forwardness = 0;
  if (abs(vexRT[Ch3]) > threshold) {
  	forwardness = vexRT[Ch3]; // set fowardness value to how far the toggle is pushed
  };
  int rightness = 0;
  if (abs(vexRT[Ch4]) > threshold) {
  	rightness = vexRT[Ch4]; // set fowardness value to how far the toggle is pushed
  };
  // Right drive
	int RightDrivePower = (forwardness - rightness) / 2 * -1;
  motor[RightBack1] = RightDrivePower;
	motor[RightBack2] = RightDrivePower;
	motor[RightFront1] = RightDrivePower;
	motor[RightFront2] = RightDrivePower;

	// Left drive
	int LeftDrivePower = (forwardness + rightness) / 2;
	motor[LeftBack1] = LeftDrivePower;
	motor[LeftBack2] = LeftDrivePower;
	motor[LeftFront1] = LeftDrivePower;
	motor[LeftFront2] = LeftDrivePower;
}


// this function changes the arm angle to the pot value that is now desired.
int calculateNewDesiredPotValue(
	int currentDesiredPotValue,
	float fractionOfFullMovementTime,
	int joystickChannel,
	int minPotValue,
	int maxPotValue
){

	int newDesiredPotValue = currentDesiredPotValue;//this is the pot value before the arm has been auto corrected
	if (abs(vexRT[joystickChannel]) > threshold) {
		float fractionJoystick = (float)vexRT[joystickChannel] / (float)127;
		float fractionJoystickInverted = fractionJoystick * -1;
		int potRange = maxPotValue - minPotValue;
		float desiredPotChangeInValue = fractionJoystickInverted * (float)potRange;
		desiredPotChangeInValue = desiredPotChangeInValue * fractionOfFullMovementTime ;
	  newDesiredPotValue = currentDesiredPotValue + desiredPotChangeInValue;
  }

  // Make sure we don't overshoot
  if (newDesiredPotValue < minPotValue) { newDesiredPotValue = minPotValue; }
  if (newDesiredPotValue > maxPotValue) { newDesiredPotValue = maxPotValue; }

  return newDesiredPotValue;
}

void armControlFromRightJoystick(){// stating the values for the rightjoystick. Note; no motor values occur here

	// Figure out how long since we were last here
	unsigned long millisecondsSinceLastJoystickCheck = nSysTime - programTimeAtLastJoystickCheck;
	if (millisecondsSinceLastJoystickCheck > 100) {
		programTimeAtLastJoystickCheck = nSysTime;

		// Figure out how much to move in this time slice
		float fractionOfFullMovementTime = (float)millisecondsSinceLastJoystickCheck / (float)millisecondsForFullShoulderTravel;
		// Figure out what the user would like the shoulder pot value to be
		desiredPotValue = calculateNewDesiredPotValue(
			desiredPotValue,
			fractionOfFullMovementTime,
			Ch2,
			PotFullyForwardValue,
			PotFullyBackwardValue
		);
	}
}

void moveOrHoldPotsAtDesiredPositions() {
	// Adjust the shoulder motor power to try to get the shoulder pot to where it should be
	int MotorError =  SensorValue[ChainBarPot] - desiredPotValue;
	int MotorPower = MotorError / 9;

	// Try to limit juddering - maybe try hysteresis?
	if (MotorPower > 100) MotorPower = 100;

//	motor[LeftArm] = MotorPower;
//	motor[RightArm] = MotorPower * -1;

}



void ClawAndMobileGoalLiftPNEMATICS(){ // pnematics use Sensor values. And function binary(1,0).

	if (vexRT[Btn8L] && GoalPosition == false) { // if the button is clicked and variable GoalPosition is set to false.
			GoalPosition = true; //change variable to true to the elif command can be initialised.
			SensorValue(goalLift) = 1; //the solenoid will be set to 1. So the goal will be lifted.
			waitUntil(vexRT[Btn8L] == 0);
		}
	else if (vexRT[Btn8L] && GoalPosition == true) { //if clicked again since variable was set to true this loop begins
			GoalPosition = false; // set back to false so that the next loop can be used when clicked again
			SensorValue(goalLift) = 0; // the solenoid will be set to 0. So the goal drops.
			waitUntil(vexRT[Btn8L] == 0);
		}

	if (vexRT[Btn8R] && ClawPosition == false) { // if the button is clicked and variable GoalPosition is set to false.
			ClawPosition = true; //change variable to true to the elif command can be initialised.
			SensorValue(claw) = 1; //the solenoid will be set to 1.
			waitUntil(vexRT[Btn8R] == 0);
		}

	 else if (vexRT[Btn8R] && ClawPosition == true) { //if clicked again since variable was set to true this loop begins
			ClawPosition = false; // set back to false so that the next loop can be used when clicked again
			SensorValue(claw) = 0; // the solenoid will be set to 0.
			waitUntil(vexRT[Btn8R] == 0);
	  }
}

task main()
{


 desiredPotValue = SensorValue[ChainBarPot];


	while(true) {
		// Check if we're in close-up mode or not
		if (vexRT[Btn6U]) {
		arcadeDriveFromLeftJoystick();
		armControlFromRightJoystick();
		} else {
		NormalTankDrive();
	}
	moveOrHoldPotsAtDesiredPositions();
	ClawAndMobileGoalLiftPNEMATICS();
  }

}
